/*
 * AM43xx Clock data
 *
 * Copyright (C) 2013 Texas Instruments, Inc.
 *
 * Paul Walmsley (paul@pwsan.com)
 * Rajendra Nayak (rnayak@ti.com)
 * Benoit Cousson (b-cousson@ti.com)
 * Mike Turquette (mturquette@ti.com)
 *
 * This file is automatically generated from the OMAP hardware databases.
 * We respectfully ask that any modifications to this file be coordinated
 * with the public linux-omap@vger.kernel.org mailing list and the
 * authors above to ensure that the autogeneration scripts are kept
 * up-to-date with the file contents.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * XXX Some of the ES1 clocks have been removed/changed; once support
 * is added for discriminating clocks by ES level, these should be added back
 * in.
 */

#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/clk-private.h>
#include <linux/clkdev.h>
#include <linux/io.h>

#include "soc.h"
#include "iomap.h"
#include "clock.h"
#include "clock43xx.h"
#include "cm43xx.h"
#include "cm-regbits-43xx.h"
#include "prm43xx.h"
#include "prm-regbits-43xx.h"
#include "control.h"

/* AM43XX_ modulemode control */
#define AM43XX_MODULEMODE_HWCTRL		0
#define AM43XX_MODULEMODE_SWCTRL		1

/* Root clocks */

DEFINE_CLK_FIXED_RATE(clk_32k_mosc_ck, CLK_IS_ROOT, 32768, 0x0);

DEFINE_CLK_FIXED_RATE(clk_32k_per_ck, CLK_IS_ROOT, 32768, 0x0);

DEFINE_CLK_FIXED_RATE(clk_32k_rc_ck, CLK_IS_ROOT, 32768, 0x0);

DEFINE_CLK_FIXED_RATE(clk_32k_rtc_ck, CLK_IS_ROOT, 32768, 0x0);

DEFINE_CLK_FIXED_RATE(clk_32k_tpm_ck, CLK_IS_ROOT, 32768, 0x0);

DEFINE_CLK_FIXED_RATE(mpu_pll_clk_ck, CLK_IS_ROOT, 0, 0x0);

DEFINE_CLK_FIXED_RATE(virt_19200000_ck, CLK_IS_ROOT, 19200000, 0x0);

DEFINE_CLK_FIXED_RATE(virt_24000000_ck, CLK_IS_ROOT, 24000000, 0x0);

DEFINE_CLK_FIXED_RATE(virt_25000000_ck, CLK_IS_ROOT, 25000000, 0x0);

DEFINE_CLK_FIXED_RATE(virt_26000000_ck, CLK_IS_ROOT, 26000000, 0x0);

static const char *sys_clkin_parents[] = {
	"virt_19200000_ck", "virt_24000000_ck", "virt_25000000_ck",
	"virt_26000000_ck",
};

DEFINE_CLK_MUX(sys_clkin, sys_clkin_parents, NULL, 0x0,
		AM33XX_CTRL_REGADDR(AM43XX_CONTROL_STATUS),
	       AM43XX_CRYSTAL_FREQ_SELECTION_SHIFT,
	       AM43XX_CRYSTAL_FREQ_SELECTION_WIDTH, CLK_MUX_INDEX_ONE, NULL);

DEFINE_CLK_FIXED_RATE(tclkin_ck, CLK_IS_ROOT, 26000000, 0x0);

static const struct clk_ops omap_hsdivider_ops = {
        .set_rate       = &omap2_clksel_set_rate,
        .recalc_rate    = &omap2_clksel_recalc,
        .round_rate     = &omap2_clksel_round_rate,
};

/* Module clocks and DPLL outputs */

/* DPLL_PER */
static struct dpll_data dpll_per_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_PER,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_PER,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_PER,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 4095,
	.max_divider	= 256,
	.min_divider	= 1,
};

static const char *dpll_per_ck_parents[] = {
	"sys_clkin",
};

static struct clk dpll_per_ck;

static const struct clk_ops dpll_per_ck_ops = {
	.enable		= &omap3_noncore_dpll_enable,
	.disable	= &omap3_noncore_dpll_disable,
	.recalc_rate	= &omap3_dpll_recalc,
	.round_rate	= &omap2_dpll_round_rate,
	.set_rate	= &omap3_noncore_dpll_set_rate,
	.get_parent	= &omap2_init_dpll_parent,
};

static struct clk_hw_omap dpll_per_ck_hw = {
	.hw = {
		.clk = &dpll_per_ck,
	},
	.dpll_data	= &dpll_per_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_per_ck, dpll_per_ck_parents, dpll_per_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_per_m2_ck, "dpll_per_ck", &dpll_per_ck, 0x0,
			    AM43XX_CM_DIV_M2_DPLL_PER,
			    AM43XX_DPLL_CLKOUT_DIV_MASK);

DEFINE_CLK_FIXED_FACTOR(clk_div_24, "dpll_per_m2_ck", &dpll_per_m2_ck, 0x0, 1,
			8);

DEFINE_CLK_DIVIDER(clkout1sel0div, "sys_clkin", &sys_clkin, 0x0,
		   AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT1SEL0DIV_SHIFT,
		   AM43XX_CLKOUT1SEL0DIV_WIDTH, 0x0, NULL);

static const char *clkout_32k_parents[] = {
	"clk_32k_tpm", "clk_32k_rtc",
};

DEFINE_CLK_MUX(clkout_32k, clkout_32k_parents, NULL, 0x0,
	       AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT_32KSEL_SHIFT,
	       AM43XX_CLKOUT_32KSEL_WIDTH, 0x0, NULL);

/* DPLL_CORE */
static struct dpll_data dpll_core_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_CORE,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_CORE,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_CORE,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 2047,
	.max_divider	= 128,
	.min_divider	= 1,
};

static struct clk dpll_core_ck;

static const struct clk_ops dpll_core_ck_ops = {
	.recalc_rate	= &omap3_dpll_recalc,
	.get_parent	= &omap2_init_dpll_parent,
};

static struct clk_hw_omap dpll_core_ck_hw = {
	.hw = {
		.clk = &dpll_core_ck,
	},
	.dpll_data	= &dpll_core_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_core_ck, dpll_per_ck_parents, dpll_core_ck_ops);

static const char *dpll_core_x2_ck_parents[] = {
	"dpll_core_ck",
};

static struct clk dpll_core_x2_ck;

static const struct clk_ops dpll_core_x2_ck_ops = {
	.recalc_rate	= &omap3_clkoutx2_recalc,
};

static struct clk_hw_omap dpll_core_x2_ck_hw = {
	.hw = {
		.clk = &dpll_core_x2_ck,
	},
};

DEFINE_STRUCT_CLK(dpll_core_x2_ck, dpll_core_x2_ck_parents,
		  dpll_core_x2_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_core_m4x2_ck, "dpll_core_x2_ck",
			    &dpll_core_x2_ck, 0x0, AM43XX_CM_DIV_M4_DPLL_CORE,
			    AM43XX_HSDIVIDER_CLKOUT1_DIV_MASK);

static const char *sysclk_div_parents[] = {
	"dpll_core_m4x2_ck",
};

static struct clk sysclk_div;

static const struct clk_ops sysclk_div_ops = {
};

static struct clk_hw_omap sysclk_div_hw = {
	.hw = {
		.clk = &sysclk_div,
	},
};

DEFINE_STRUCT_CLK(sysclk_div, sysclk_div_parents, sysclk_div_ops);

/* DPLL_DDR */
static struct dpll_data dpll_ddr_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_DDR,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_DDR,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_DDR,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 2047,
	.max_divider	= 128,
	.min_divider	= 1,
};

static struct clk dpll_ddr_ck;

static struct clk_hw_omap dpll_ddr_ck_hw = {
	.hw = {
		.clk = &dpll_ddr_ck,
	},
	.dpll_data	= &dpll_ddr_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_ddr_ck, dpll_per_ck_parents, dpll_per_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_ddr_m2_ck, "dpll_ddr_ck", &dpll_ddr_ck, 0x0,
			    AM43XX_CM_DIV_M2_DPLL_DDR,
			    AM43XX_DPLL_CLKOUT_DIV_MASK);

/* DPLL_DISP */
static struct dpll_data dpll_disp_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_DISP,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_DISP,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_DISP,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 2047,
	.max_divider	= 128,
	.min_divider	= 1,
};

static struct clk dpll_disp_ck;

static struct clk_hw_omap dpll_disp_ck_hw = {
	.hw = {
		.clk = &dpll_disp_ck,
	},
	.dpll_data	= &dpll_disp_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_disp_ck, dpll_per_ck_parents, dpll_per_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_disp_m2_ck, "dpll_disp_ck", &dpll_disp_ck, 0x0,
			    AM43XX_CM_DIV_M2_DPLL_DISP,
			    AM43XX_DPLL_CLKOUT_DIV_MASK);

static const char *clkout1sel2_prediv_parents[] = {
	"clkout_32k", "sysclk_div", "dpll_ddr_m2_ck",
	"dpll_per_m2_ck", "dpll_disp_m2_ck", "mpu_pll_clk",
};

DEFINE_CLK_MUX(clkout1sel2_prediv, clkout1sel2_prediv_parents, NULL, 0x0,
	       AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT1SEL2SOURCE_SHIFT,
	       AM43XX_CLKOUT1SEL2SOURCE_WIDTH, 0x0, NULL);

DEFINE_CLK_DIVIDER(clkout1sel2div1, "clkout1sel2_prediv", &clkout1sel2_prediv,
		   0x0, AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT1SEL2DIV2_SHIFT,
		   AM43XX_CLKOUT1SEL2DIV2_WIDTH, 0x0, NULL);

DEFINE_CLK_DIVIDER(clkout1sel2div2, "clkout1sel2div1", &clkout1sel2div1, 0x0,
		   AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT1SEL2DIV2_SHIFT,
		   AM43XX_CLKOUT1SEL2DIV2_WIDTH, CLK_DIVIDER_POWER_OF_TWO,
		   NULL);

static const char *clkout2_mux1_out_parents[] = {
	"clkout_32k", "sysclk_div", "dpll_ddr_m2_ck",
	"dpll_per_m2_ck",
};

DEFINE_CLK_MUX(clkout2_mux1_out, clkout2_mux1_out_parents, NULL, 0x0,
	       AM43XX_CM_CLKOUT2_CTRL, AM43XX_CLKOUT2SOURCE_SHIFT,
	       AM43XX_CLKOUT2SOURCE_WIDTH, 0x0, NULL);

/* DPLL_EXTDEV */
static struct dpll_data dpll_extdev_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_EXTDEV,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_EXTDEV,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_EXTDEV,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 4095,
	.max_divider	= 256,
	.min_divider	= 1,
};

static struct clk dpll_extdev_ck;

static struct clk_hw_omap dpll_extdev_ck_hw = {
	.hw = {
		.clk = &dpll_extdev_ck,
	},
	.dpll_data	= &dpll_extdev_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_extdev_ck, dpll_per_ck_parents, dpll_per_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_extdev_m2_ck, "dpll_extdev_ck",
			    &dpll_extdev_ck, 0x0, AM43XX_CM_DIV_M2_DPLL_EXTDEV,
			    AM43XX_DPLL_CLKOUT_DIV_MASK);

static const char *clkout2_mux2_out_parents[] = {
	"dpll_disp_m2_ck", "mpu_pll_clk", "dpll_extdev_m2_ck",
	"dpll_extdev_m2_ck",
};

DEFINE_CLK_MUX(clkout2_mux2_out, clkout2_mux2_out_parents, NULL, 0x0,
	       AM43XX_CM_CLKOUT1_CTRL, AM43XX_CLKOUT1SOURCE_SHIFT,
	       AM43XX_CLKOUT1SOURCE_WIDTH, 0x0, NULL);

#ifndef CONFIG_SOC_AM43XX
static const char *clkout2_prediv_parents[] = {
	"clkout2_mux1_out", "clkout2_mux2_out",
};

DEFINE_CLK_MUX(clkout2_prediv, clkout2_prediv_parents, NULL, 0x0, AM43XX_,
	       AM43XX__SHIFT, AM43XX__WIDTH, 0x0, NULL);

DEFINE_CLK_DIVIDER(clkout2_div1, "clkout2_prediv", &clkout2_prediv, 0x0,
		   AM43XX_CM_CLKOUT2_CTRL, AM43XX_CLKOUT2DIV_SHIFT,
		   AM43XX_CLKOUT2DIV_WIDTH, 0x0, NULL);

DEFINE_CLK_DIVIDER(clkout2_div2, "clkout2_div1", &clkout2_div1, 0x0,
		   AM43XX_CM_CLKOUT2_CTRL, AM43XX_CLKOUT2POSTDIV_SHIFT,
		   AM43XX_CLKOUT2POSTDIV_WIDTH, CLK_DIVIDER_POWER_OF_TWO, NULL);
#endif 

DEFINE_CLK_FIXED_FACTOR(core_l4_clkdiv, "sysclk_div", &sysclk_div, 0x0, 1, 2);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_core_m5x2_ck, "dpll_core_x2_ck",
			    &dpll_core_x2_ck, 0x0, AM43XX_CM_DIV_M5_DPLL_CORE,
			    AM43XX_HSDIVIDER_CLKOUT2_DIV_MASK);

DEFINE_CLK_FIXED_FACTOR(cpsw_125mhz_ocp_ck, "dpll_core_m5x2_ck",
			&dpll_core_m5x2_ck, 0x0, 1, 2);

static const char *cpsw_50m_clkdiv_parents[] = {
	"dpll_core_m5x2_ck",
};

static struct clk cpsw_50m_clkdiv;

static struct clk_hw_omap cpsw_50m_clkdiv_hw = {
	.hw = {
		.clk = &cpsw_50m_clkdiv,
	},
};

DEFINE_STRUCT_CLK(cpsw_50m_clkdiv, cpsw_50m_clkdiv_parents, sysclk_div_ops);

DEFINE_CLK_FIXED_FACTOR(cpsw_5m_clkdiv, "cpsw_50m_clkdiv", &cpsw_50m_clkdiv,
			0x0, 1, 10);

static const char *cpts_rft_clkmux_parents[] = {
	"sysclk_div", "dpll_core_m5x2_ck", "dpll_disp_m2_ck",
};

DEFINE_CLK_MUX(cpts_rft_clkmux, cpts_rft_clkmux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_CPTS_RFT_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

static const char *disp_clk_parents[] = {
	"dpll_disp_m2_ck", "dpll_core_m5x2_ck", "dpll_per_m2_ck",
};

DEFINE_CLK_MUX(disp_clk, disp_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_LCDC_PIXEL_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(div_core_25m_ck, "sysclk_div", &sysclk_div, 0x0, 1, 8);

static const char *sgx_clksel_parents[] = {
	"sysclk_div", "dpll_per_m2_ck",
};

DEFINE_CLK_MUX(sgx_clksel, sgx_clksel_parents, NULL, 0x0,
	       AM43XX_CLKSEL_GFX_FCLK, AM43XX_CLKSEL_GFX_FCLK_SHIFT,
	       AM43XX_CLKSEL_GFX_FCLK_WIDTH, 0x0, NULL);

DEFINE_CLK_DIVIDER(div_gfx_fclk, "sgx_clksel", &sgx_clksel, 0x0,
		   AM43XX_CLKSEL_GFX_FCLK, AM43XX_CLKDIV_SEL_GFX_FCLK_SHIFT,
		   AM43XX_CLKDIV_SEL_GFX_FCLK_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(div_usim_fclk, "sysclk_div", &sysclk_div, 0x0, 1, 5);

static const struct clk_div_table dll_aging_clk_div_rates[] = {
	{ .div = 8, .val = 0 },
	{ .div = 16, .val = 1 },
	{ .div = 32, .val = 2 },
	{ .div = 0 },
};
DEFINE_CLK_DIVIDER_TABLE(dll_aging_clk_div, "sys_clkin", &sys_clkin, 0x0,
			 AM43XX_CLKSEL_DLL_AGING_CLK, AM43XX_CLKSEL_SHIFT,
			 AM43XX_CLKSEL_WIDTH, 0x0, dll_aging_clk_div_rates,
			 NULL);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_core_m6x2_ck, "dpll_core_x2_ck",
			    &dpll_core_x2_ck, 0x0, AM43XX_CM_DIV_M6_DPLL_CORE,
			    AM43XX_HSDIVIDER_CLKOUT3_DIV_MASK);

static const char *dpll_ddr_x2_ck_parents[] = {
	"dpll_ddr_ck",
};

static struct clk dpll_ddr_x2_ck;

static struct clk_hw_omap dpll_ddr_x2_ck_hw = {
	.hw = {
		.clk = &dpll_ddr_x2_ck,
	},
};

DEFINE_STRUCT_CLK(dpll_ddr_x2_ck, dpll_ddr_x2_ck_parents, dpll_core_x2_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_ddr_m4x2_ck, "dpll_ddr_x2_ck", &dpll_ddr_x2_ck,
			    0x0, AM43XX_CM_DIV_M4_DPLL_DDR,
			    AM43XX_HSDIVIDER_CLKOUT1_DIV_MASK);

/* DPLL_MPU */
static struct dpll_data dpll_mpu_dd = {
	.mult_div1_reg	= AM43XX_CM_CLKSEL_DPLL_MPU,
	.clk_bypass	= &sys_clkin,
	.clk_ref	= &sys_clkin,
	.control_reg	= AM43XX_CM_CLKMODE_DPLL_MPU,
	.modes		= (1 << DPLL_LOW_POWER_BYPASS) | (1 << DPLL_LOCKED),
	.idlest_reg	= AM43XX_CM_IDLEST_DPLL_MPU,
	.mult_mask	= AM43XX_DPLL_MULT_MASK,
	.div1_mask	= AM43XX_DPLL_DIV_MASK,
	.enable_mask	= AM43XX_DPLL_EN_MASK,
	.idlest_mask	= AM43XX_ST_DPLL_CLK_MASK,
	.max_multiplier	= 2047,
	.max_divider	= 128,
	.min_divider	= 1,
};

static struct clk dpll_mpu_ck;

static struct clk_hw_omap dpll_mpu_ck_hw = {
	.hw = {
		.clk = &dpll_mpu_ck,
	},
	.dpll_data	= &dpll_mpu_dd,
	.ops		= &clkhwops_omap3_dpll,
};

DEFINE_STRUCT_CLK(dpll_mpu_ck, dpll_per_ck_parents, dpll_per_ck_ops);

DEFINE_CLK_OMAP_HSDIVIDER(dpll_mpu_m2_ck, "dpll_mpu_ck", &dpll_mpu_ck, 0x0,
			    AM43XX_CM_DIV_M2_DPLL_MPU,
			    AM43XX_DPLL_CLKOUT_DIV_MASK);

static const char *dpll_per_clkdcoldo_parents[] = {
	"dpll_per_ck",
};

static struct clk dpll_per_clkdcoldo;

static struct clk_hw_omap dpll_per_clkdcoldo_hw = {
	.hw = {
		.clk = &dpll_per_clkdcoldo,
	},
	.clksel_reg	= AM43XX_CM_CLKDCOLDO_DPLL_PER,
};

DEFINE_STRUCT_CLK(dpll_per_clkdcoldo, dpll_per_clkdcoldo_parents,
		  sysclk_div_ops);

DEFINE_CLK_FIXED_FACTOR(func_12m_clk, "dpll_per_m2_ck", &dpll_per_m2_ck, 0x0, 1,
			16);

static const char *gpio_dbclk_mux_parents[] = {
	"clk_32k_rc", "clk_32k_rtc", "clk_32k_per",
	"clk_32k_mosc", "clk_32k_tpm",
};

DEFINE_CLK_MUX(gpio_dbclk_mux, gpio_dbclk_mux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_GPIO0_DBCLK, AM43XX_CLKSEL_0_2_SHIFT,
	       AM43XX_CLKSEL_0_2_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(i2c_clk, "dpll_per_m2_ck", &dpll_per_m2_ck, 0x0, 1, 4);

static const char *icss_ocp_clk_mux_parents[] = {
	"sysclk_div", "dpll_disp_m2_ck",
};

DEFINE_CLK_MUX(icss_ocp_clk_mux, icss_ocp_clk_mux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_ICSS_OCP_CLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(mmc_clk, "dpll_per_m2_ck", &dpll_per_m2_ck, 0x0, 1, 2);

#ifndef CONFIG_SOC_AM43XX
static const char *mux_clkout1_parents[] = {
	"clkout1sel0div", "clkout_32k", "clkout1sel2div2",
	"dpll_extdev_m2_ck",
};

DEFINE_CLK_MUX(mux_clkout1, mux_clkout1_parents, NULL, 0x0, AM43XX_,
	       AM43XX__SHIFT, AM43XX__WIDTH, 0x0, NULL);
#endif 

static const char *mux_mag_fclk_parents[] = {
	"sys_clkin", "dpll_per_m2_ck",
};

DEFINE_CLK_MUX(mux_mag_fclk, mux_mag_fclk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_MAG_CARD_CLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

static const char *mux_synctimer32k_ck_parents[] = {
	"clk_32k_rtc", "clk_32k_tpm", "clk_32k_per",
};

DEFINE_CLK_MUX(mux_synctimer32k_ck, mux_synctimer32k_ck_parents, NULL, 0x0,
	       AM43XX_CLKSEL_SYNCTIMER_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

#ifndef CONFIG_SOC_AM43XX
static const char *timer0_gclk_parents[] = {
	"clk_32k_rc", "clk_32k_tpm", "sys_clkin",
};

DEFINE_CLK_MUX(timer0_gclk, timer0_gclk_parents, NULL, 0x0, AM43XX_,
	       AM43XX__SHIFT, AM43XX__WIDTH, 0x0, NULL);
#endif 
static const char *timer10_clk_parents[] = {
	"tclkin", "sys_clkin", "clk_32k_per",
	"clk_32k_tpm",
};

DEFINE_CLK_MUX(timer10_clk, timer10_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER10_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer11_clk, timer10_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER11_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

static const char *timer1_clkmux_parents[] = {
	"sys_clkin", "clk_32k_per", "tclkin",
	"clk_32k_rc", "clk_32k_rtc", "clk_32k_tpm",
};

DEFINE_CLK_MUX(timer1_clkmux, timer1_clkmux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER1MS_CLK, AM43XX_CLKSEL_0_2_SHIFT,
	       AM43XX_CLKSEL_0_2_WIDTH, 0x0, NULL);

static const char *timer2_clk_parents[] = {
	"tclkin", "sys_clkin", "clk_32k_per",
};

DEFINE_CLK_MUX(timer2_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER2_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer3_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER3_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer4_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER4_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer5_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER5_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer6_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER6_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer7_clk, timer2_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER7_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer8_clk, timer10_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER8_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(timer9_clk, timer10_clk_parents, NULL, 0x0,
	       AM43XX_CLKSEL_TIMER9_CLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(uart0_clk, "dpll_per_m2_ck", &dpll_per_m2_ck, 0x0, 1,
			4);

static const char *usbphy_32khz_clkmux_parents[] = {
	"clk_32k_rtc", "clk_32k_tpm",
};

DEFINE_CLK_MUX(usbphy_32khz_clkmux, usbphy_32khz_clkmux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_USBPHY32KHZ_GCLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

static const char *usim0_fclk_mux_parents[] = {
	"sys_clkin", "div_usim_fclk",
};

DEFINE_CLK_MUX(usim0_fclk_mux, usim0_fclk_mux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_USIM0_FCLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

DEFINE_CLK_MUX(usim1_fclk_mux, usim0_fclk_mux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_USIM1_FCLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

static const char *usim_dbclkmux_parents[] = {
	"clk_32k_rc", "clk_32k_per", "clk_32k_mosc",
};

DEFINE_CLK_MUX(usim_dbclkmux, usim_dbclkmux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_USIM_DBCLK, AM43XX_CLKSEL_SHIFT,
	       AM43XX_CLKSEL_WIDTH, 0x0, NULL);

DEFINE_CLK_FIXED_FACTOR(vtp_clk_div, "sys_clkin", &sys_clkin, 0x0, 1, 2);

#ifndef CONFIG_SOC_AM43XX
static const char *wdt0_gclk_parents[] = {
	"clk_32k_rc", "clk_32k_tpm",
};

DEFINE_CLK_MUX(wdt0_gclk, wdt0_gclk_parents, NULL, 0x0, AM43XX_, AM43XX__SHIFT,
	       AM43XX__WIDTH, 0x0, NULL);
#endif 
static const char *wdt1_clkmux_parents[] = {
	"clk_32k_rc", "clk_32k_per",
};

DEFINE_CLK_MUX(wdt1_clkmux, wdt1_clkmux_parents, NULL, 0x0,
	       AM43XX_CLKSEL_WDT1_CLK, AM43XX_CLKSEL_0_0_SHIFT,
	       AM43XX_CLKSEL_0_0_WIDTH, 0x0, NULL);

/* Leaf clocks controlled by modules */

DEFINE_CLK_GATE(usim0_fclk, "usim0_fclk_mux", &usim0_fclk_mux, 0x0,
		AM43XX_CM_PER_USIM0_CLKCTRL, AM43XX_OPTFCLKEN_FCLK_SHIFT, 0x0,
		NULL);

DEFINE_CLK_GATE(usim0_fclk32, "usim_dbclkmux", &usim_dbclkmux, 0x0,
		AM43XX_CM_PER_USIM0_CLKCTRL, AM43XX_OPTFCLKEN_FCLK32_SHIFT, 0x0,
		NULL);

DEFINE_CLK_GATE(usim1_fclk, "usim1_fclk_mux", &usim1_fclk_mux, 0x0,
		AM43XX_CM_PER_USIM1_CLKCTRL, AM43XX_OPTFCLKEN_FCLK_SHIFT, 0x0,
		NULL);

DEFINE_CLK_GATE(usim1_fclk32, "usim_dbclkmux", &usim_dbclkmux, 0x0,
		AM43XX_CM_PER_USIM1_CLKCTRL, AM43XX_OPTFCLKEN_FCLK32_SHIFT, 0x0,
		NULL);

/* Remaining optional clocks */
/*
 * clkdev
 */

static struct omap_clk am43xx_clks[] = {
	CLK(NULL,	"clk_32k_mosc_ck",	&clk_32k_mosc_ck),
	CLK(NULL,	"clk_32k_per_ck",	&clk_32k_per_ck),
	CLK(NULL,	"clk_32k_rc_ck",	&clk_32k_rc_ck),
	CLK(NULL,	"clk_32k_rtc_ck",	&clk_32k_rtc_ck),
	CLK(NULL,	"clk_32k_tpm_ck",	&clk_32k_tpm_ck),
	CLK(NULL,	"mpu_pll_clk_ck",	&mpu_pll_clk_ck),
	CLK(NULL,	"virt_19200000_ck",	&virt_19200000_ck),
	CLK(NULL,	"virt_24000000_ck",	&virt_24000000_ck),
	CLK(NULL,	"virt_25000000_ck",	&virt_25000000_ck),
	CLK(NULL,	"virt_26000000_ck",	&virt_26000000_ck),
	CLK(NULL,	"sys_clkin",		&sys_clkin),
	CLK(NULL,	"tclkin_ck",		&tclkin_ck),
	CLK(NULL,	"dpll_per_ck",		&dpll_per_ck),
	CLK(NULL,	"dpll_per_m2_ck",	&dpll_per_m2_ck),
	CLK(NULL,	"clk_div_24",		&clk_div_24),
	CLK(NULL,	"clkout1sel0div",	&clkout1sel0div),
	CLK(NULL,	"clkout_32k",		&clkout_32k),
	CLK(NULL,	"dpll_core_ck",		&dpll_core_ck),
	CLK(NULL,	"dpll_core_x2_ck",	&dpll_core_x2_ck),
	CLK(NULL,	"dpll_core_m4x2_ck",	&dpll_core_m4x2_ck),
	CLK(NULL,	"sysclk_div",		&sysclk_div),
	CLK(NULL,	"dpll_ddr_ck",		&dpll_ddr_ck),
	CLK(NULL,	"dpll_ddr_m2_ck",	&dpll_ddr_m2_ck),
	CLK(NULL,	"dpll_disp_ck",		&dpll_disp_ck),
	CLK(NULL,	"dpll_disp_m2_ck",	&dpll_disp_m2_ck),
	CLK(NULL,	"clkout1sel2_prediv",	&clkout1sel2_prediv),
	CLK(NULL,	"clkout1sel2div1",	&clkout1sel2div1),
	CLK(NULL,	"clkout1sel2div2",	&clkout1sel2div2),
	CLK(NULL,	"clkout2_mux1_out",	&clkout2_mux1_out),
	CLK(NULL,	"dpll_extdev_ck",	&dpll_extdev_ck),
	CLK(NULL,	"dpll_extdev_m2_ck",	&dpll_extdev_m2_ck),
	CLK(NULL,	"clkout2_mux2_out",	&clkout2_mux2_out),
#ifndef CONFIG_SOC_AM43XX
	CLK(NULL,	"clkout2_prediv",	&clkout2_prediv),
	CLK(NULL,	"clkout2_div1",		&clkout2_div1),
	CLK(NULL,	"clkout2_div2",		&clkout2_div2),
#endif 
	CLK(NULL,	"core_l4_clkdiv",	&core_l4_clkdiv),
	CLK(NULL,	"dpll_core_m5x2_ck",	&dpll_core_m5x2_ck),
	CLK(NULL,	"cpsw_125mhz_ocp_ck",	&cpsw_125mhz_ocp_ck),
	CLK(NULL,	"cpsw_50m_clkdiv",	&cpsw_50m_clkdiv),
	CLK(NULL,	"cpsw_5m_clkdiv",	&cpsw_5m_clkdiv),
	CLK(NULL,	"cpts_rft_clkmux",	&cpts_rft_clkmux),
	CLK(NULL,	"disp_clk",		&disp_clk),
	CLK(NULL,	"div_core_25m_ck",	&div_core_25m_ck),
	CLK(NULL,	"sgx_clksel",		&sgx_clksel),
	CLK(NULL,	"div_gfx_fclk",		&div_gfx_fclk),
	CLK(NULL,	"div_usim_fclk",	&div_usim_fclk),
	CLK(NULL,	"dll_aging_clk_div",	&dll_aging_clk_div),
	CLK(NULL,	"dpll_core_m6x2_ck",	&dpll_core_m6x2_ck),
	CLK(NULL,	"dpll_ddr_x2_ck",	&dpll_ddr_x2_ck),
	CLK(NULL,	"dpll_ddr_m4x2_ck",	&dpll_ddr_m4x2_ck),
	CLK(NULL,	"dpll_mpu_ck",		&dpll_mpu_ck),
	CLK(NULL,	"dpll_mpu_m2_ck",	&dpll_mpu_m2_ck),
	CLK(NULL,	"dpll_per_clkdcoldo",	&dpll_per_clkdcoldo),
	CLK(NULL,	"func_12m_clk",		&func_12m_clk),
	CLK(NULL,	"gpio_dbclk_mux",	&gpio_dbclk_mux),
	CLK(NULL,	"i2c_clk",		&i2c_clk),
	CLK(NULL,	"icss_ocp_clk_mux",	&icss_ocp_clk_mux),
	CLK(NULL,	"mmc_clk",		&mmc_clk),
#ifndef CONFIG_SOC_AM43XX
	CLK(NULL,	"mux_clkout1",		&mux_clkout1),
#endif 
	CLK(NULL,	"mux_mag_fclk",		&mux_mag_fclk),
	CLK(NULL,	"mux_synctimer32k_ck",	&mux_synctimer32k_ck),
#ifndef CONFIG_SOC_AM43XX
	CLK(NULL,	"timer0_gclk",		&timer0_gclk),
#endif 
	CLK(NULL,	"timer10_clk",		&timer10_clk),
	CLK(NULL,	"timer11_clk",		&timer11_clk),
	CLK(NULL,	"timer1_clkmux",	&timer1_clkmux),
	CLK(NULL,	"timer2_clk",		&timer2_clk),
	CLK(NULL,	"timer3_clk",		&timer3_clk),
	CLK(NULL,	"timer4_clk",		&timer4_clk),
	CLK(NULL,	"timer5_clk",		&timer5_clk),
	CLK(NULL,	"timer6_clk",		&timer6_clk),
	CLK(NULL,	"timer7_clk",		&timer7_clk),
	CLK(NULL,	"timer8_clk",		&timer8_clk),
	CLK(NULL,	"timer9_clk",		&timer9_clk),
	CLK(NULL,	"uart0_clk",		&uart0_clk),
	CLK(NULL,	"usbphy_32khz_clkmux",	&usbphy_32khz_clkmux),
	CLK(NULL,	"usim0_fclk_mux",	&usim0_fclk_mux),
	CLK(NULL,	"usim1_fclk_mux",	&usim1_fclk_mux),
	CLK(NULL,	"usim_dbclkmux",	&usim_dbclkmux),
	CLK(NULL,	"vtp_clk_div",		&vtp_clk_div),
#ifndef CONFIG_SOC_AM43XX
	CLK(NULL,	"wdt0_gclk",		&wdt0_gclk),
#endif 
	CLK(NULL,	"wdt1_clkmux",		&wdt1_clkmux),
	CLK(NULL,	"usim0_fclk",		&usim0_fclk),
	CLK(NULL,	"usim0_fclk32",		&usim0_fclk32),
	CLK(NULL,	"usim1_fclk",		&usim1_fclk),
	CLK(NULL,	"usim1_fclk32",		&usim1_fclk32),
	CLK(NULL,	"gpmc_ck",		&dummy_ck),
	CLK("omap_i2c.1",	"ick",		&dummy_ck),
	CLK("omap_i2c.2",	"ick",		&dummy_ck),
	CLK("omap_i2c.3",	"ick",		&dummy_ck),
	CLK("omap_i2c.4",	"ick",		&dummy_ck),
	CLK(NULL,	"mailboxes_ick",	&dummy_ck),
	CLK("omap_hsmmc.0",	"ick",		&dummy_ck),
	CLK("omap_hsmmc.1",	"ick",		&dummy_ck),
	CLK("omap_hsmmc.2",	"ick",		&dummy_ck),
	CLK("omap_hsmmc.3",	"ick",		&dummy_ck),
	CLK("omap_hsmmc.4",	"ick",		&dummy_ck),
	CLK("omap-mcbsp.1",	"ick",		&dummy_ck),
	CLK("omap-mcbsp.2",	"ick",		&dummy_ck),
	CLK("omap-mcbsp.3",	"ick",		&dummy_ck),
	CLK("omap-mcbsp.4",	"ick",		&dummy_ck),
	CLK("omap2_mcspi.1",	"ick",		&dummy_ck),
	CLK("omap2_mcspi.2",	"ick",		&dummy_ck),
	CLK("omap2_mcspi.3",	"ick",		&dummy_ck),
	CLK("omap2_mcspi.4",	"ick",		&dummy_ck),
	CLK(NULL,	"uart1_ick",		&dummy_ck),
	CLK(NULL,	"uart2_ick",		&dummy_ck),
	CLK(NULL,	"uart3_ick",		&dummy_ck),
	CLK(NULL,	"uart4_ick",		&dummy_ck),
	CLK("usbhs_omap",	"usbhost_ick",	&dummy_ck),
	CLK("usbhs_omap",	"usbtll_fck",	&dummy_ck),
	CLK("omap_wdt",	"ick",			&dummy_ck),
	CLK(NULL,       "timer_sys_ck",         &sys_clkin),
};

/*
 * Prepare and enable a list of clocks.
 * XXX Deprecated: Only needed until these clocks are properly claimed
 * and enabled by the drivers or core code thats uses them.
 */

static const char *enable_init_clks[] = {
};

int __init am5xxx_clk_init(void)
{
	if (soc_is_am43xx())
		cpu_mask = RATE_IN_43XX;

	/*
	 * Must stay commented until all OMAP SoC drivers are
	 * converted to runtime PM, or drivers may start crashing
	 *
	 * omap2_clk_disable_clkdm_control();
	 */
	omap_clocks_register(am43xx_clks, ARRAY_SIZE(am43xx_clks));

	omap2_clk_disable_autoidle_all();

	omap2_clk_enable_init_clocks(enable_init_clks,
				     ARRAY_SIZE(enable_init_clks));

	return 0;
}
