/*
 * omap_hwmod_33xx_data.c: Hardware modules present on the AM33XX chips
 *
 * Copyright (C) {2012} Texas Instruments Incorporated - http://www.ti.com/
 *
 * This file is automatically generated from the AM33XX hardware databases.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation version 2.
 *
 * This program is distributed "as is" WITHOUT ANY WARRANTY of any
 * kind, whether express or implied; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 */

#include "omap_hwmod.h"
#include "omap_hwmod_common_data.h"

#include "control.h"
#include "cm81xx.h"
#include "prm81xx.h"

/*
 * IP blocks
 */

/*
 * 'l3' class
 * instance(s): l3_slow
 */
static struct omap_hwmod_class ti81xx_l3_slow_hwmod_class = {
	.name		= "l3_slow",
};

/* l3_slow */
static struct omap_hwmod ti81xx_l3_slow_hwmod = {
	.name		= "l3_slow",
	.class		= &ti81xx_l3_slow_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
};

/*
 * 'mpu' class
 */
static struct omap_hwmod_class ti81xx_mpu_hwmod_class = {
	.name	= "mpu",
};

/* mpu */
static struct omap_hwmod ti81xx_mpu_hwmod = {
	.name		= "mpu",
	.class		= &ti81xx_mpu_hwmod_class,
	.clkdm_name	= "mpu_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_MPU_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

/* 'timer 2-7' class */
static struct omap_hwmod_class_sysconfig ti81xx_timer_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			  SIDLE_SMART_WKUP),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod_class ti81xx_timer_hwmod_class = {
	.name		= "timer",
	.sysc		= &ti81xx_timer_sysc,
};

#if 0
/* timer1 1ms */
static struct omap_hwmod_class_sysconfig ti81xx_timer1ms_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SIDLEMODE |
			SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE |
			SYSS_HAS_RESET_STATUS),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_class ti81xx_timer1ms_hwmod_class = {
	.name		= "timer",
	.sysc		= &ti81xx_timer1ms_sysc,
};
#endif

static struct omap_hwmod ti81xx_timer1_hwmod = {
	.name		= "timer1",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_1_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer2_hwmod = {
	.name		= "timer2",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_2_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer3_hwmod = {
	.name		= "timer3",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_3_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer4_hwmod = {
	.name		= "timer4",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_4_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer5_hwmod = {
	.name		= "timer5",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_5_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer6_hwmod = {
	.name		= "timer6",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_6_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_timer7_hwmod = {
	.name		= "timer7",
	.class		= &ti81xx_timer_hwmod_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_TIMER_7_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

/* 'uart' class */
static struct omap_hwmod_class_sysconfig uart_sysc = {
	.rev_offs	= 0x50,
	.sysc_offs	= 0x54,
	.syss_offs	= 0x58,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_ENAWAKEUP |
			  SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			  SIDLE_SMART_WKUP),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_class uart_class = {
	.name		= "uart",
	.sysc		= &uart_sysc,
};

/* uart1 */
static struct omap_hwmod ti81xx_uart1_hwmod = {
	.name		= "uart1",
	.class		= &uart_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_UART_0_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

static struct omap_hwmod ti81xx_uart2_hwmod = {
	.name		= "uart2",
	.class		= &uart_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_UART_1_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

/* uart3 */
static struct omap_hwmod ti81xx_uart3_hwmod = {
	.name		= "uart3",
	.class		= &uart_class,
	.clkdm_name	= "l3slow_alwon_clkdm",
	.flags		= (HWMOD_INIT_NO_IDLE | HWMOD_INIT_NO_RESET),
	.prcm		= {
		.omap4	= {
			.clkctrl_offs	= TI81XX_CM_ALWON_UART_2_CLKCTRL_OFFSET,
			.modulemode	= MODULEMODE_SWCTRL,
		},
	},
};

/*
 * Interfaces
 */
/* mpu -> l3 slow */
static struct omap_hwmod_ocp_if ti81xx_mpu__l3_slow = {
	.master		= &ti81xx_mpu_hwmod,
	.slave		= &ti81xx_l3_slow_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> l4 slow */
#if 0
static struct omap_hwmod_ocp_if ti81xx_l3_slow__l4_slow = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_l4_slow_hwmod,
	.clk		= "l3s_gclk",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};
#endif

/* l3 slow -> timer1 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer1 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer1_hwmod,
	.user		= OCP_USER_MPU,
};

//* l3 slow -> timer2 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer2 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer2_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> timer3 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer3 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer3_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> timer4 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer4 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer4_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> timer5 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer5 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer5_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> timer6 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer6 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer6_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> timer7 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__timer7 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_timer7_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> uart1 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__uart1 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_uart1_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> uart2 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__uart2 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_uart2_hwmod,
	.user		= OCP_USER_MPU,
};

/* l3 slow -> uart3 */
static struct omap_hwmod_ocp_if ti81xx_l3_slow__uart3 = {
	.master		= &ti81xx_l3_slow_hwmod,
	.slave		= &ti81xx_uart3_hwmod,
	.user		= OCP_USER_MPU,
};

/* looks like the clk entry in hwmod is optional? */

static struct omap_hwmod_ocp_if *ti81xx_hwmod_ocp_ifs[] __initdata = {
	&ti81xx_mpu__l3_slow,
	&ti81xx_l3_slow__timer1,
	&ti81xx_l3_slow__timer2,
	&ti81xx_l3_slow__timer3,
	&ti81xx_l3_slow__timer4,
	&ti81xx_l3_slow__timer5,
	&ti81xx_l3_slow__timer6,
	&ti81xx_l3_slow__timer7,
	&ti81xx_l3_slow__uart1,
	&ti81xx_l3_slow__uart2,
	&ti81xx_l3_slow__uart3,
	NULL,
};

int __init ti81xx_hwmod_init(void)
{
	omap_hwmod_init();
	return omap_hwmod_register_links(ti81xx_hwmod_ocp_ifs);
}
